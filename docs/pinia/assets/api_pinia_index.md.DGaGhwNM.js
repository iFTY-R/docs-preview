import{_ as e,c as a,o as r,a2 as o}from"./chunks/framework.DMet4H9D.js";const u=JSON.parse('{"title":"pinia","description":"","frontmatter":{"editLink":false},"headers":[],"relativePath":"api/pinia/index.md","filePath":"api/pinia/index.md"}'),n={name:"api/pinia/index.md"};function i(s,t,d,c,l,h){return r(),a("div",null,t[0]||(t[0]=[o('<p><a href="./../">@pinia/root</a> / pinia</p><h1 id="pinia" tabindex="-1">pinia <a class="header-anchor" href="#pinia" aria-label="Permalink to &quot;pinia&quot;">​</a></h1><h2 id="Enumerations" tabindex="-1">Enumerations <a class="header-anchor" href="#Enumerations" aria-label="Permalink to &quot;Enumerations&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Enumeration</th><th>Description</th></tr></thead><tbody><tr><td><a href="./enumerations/MutationType.html">MutationType</a></td><td>Possible types for SubscriptionCallback</td></tr></tbody></table><h2 id="Interfaces" tabindex="-1">Interfaces <a class="header-anchor" href="#Interfaces" aria-label="Permalink to &quot;Interfaces&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Interface</th><th>Description</th></tr></thead><tbody><tr><td><a href="./interfaces/StoreOnActionListenerContext.html">_StoreOnActionListenerContext</a></td><td>Actual type for <a href="./type-aliases/StoreOnActionListenerContext.html">StoreOnActionListenerContext</a>. Exists for refactoring purposes. For internal use only. For internal use <strong>only</strong></td></tr><tr><td><a href="./interfaces/StoreWithState.html">_StoreWithState</a></td><td>Base store with state and functions. Should not be used directly.</td></tr><tr><td><a href="./interfaces/SubscriptionCallbackMutationBase.html">_SubscriptionCallbackMutationBase</a></td><td>Base type for the context passed to a subscription callback. Internal type.</td></tr><tr><td><a href="./interfaces/DefineSetupStoreOptions.html">DefineSetupStoreOptions</a></td><td>Options parameter of <code>defineStore()</code> for setup stores. Can be extended to augment stores with the plugin API.</td></tr><tr><td><a href="./interfaces/DefineStoreOptions.html">DefineStoreOptions</a></td><td>Options parameter of <code>defineStore()</code> for option stores. Can be extended to augment stores with the plugin API.</td></tr><tr><td><a href="./interfaces/DefineStoreOptionsBase.html">DefineStoreOptionsBase</a></td><td>Options passed to <code>defineStore()</code> that are common between option and setup stores. Extend this interface if you want to add custom options to both kinds of stores.</td></tr><tr><td><a href="./interfaces/DefineStoreOptionsInPlugin.html">DefineStoreOptionsInPlugin</a></td><td>Available <code>options</code> when creating a pinia plugin.</td></tr><tr><td><a href="./interfaces/MapStoresCustomization.html">MapStoresCustomization</a></td><td>Interface to allow customizing map helpers. Extend this interface with the following properties:</td></tr><tr><td><a href="./interfaces/Pinia.html">Pinia</a></td><td>Every application must own its own pinia to be able to create stores</td></tr><tr><td><a href="./interfaces/PiniaCustomProperties.html">PiniaCustomProperties</a></td><td>Interface to be extended by the user when they add properties through plugins.</td></tr><tr><td><a href="./interfaces/PiniaCustomStateProperties.html">PiniaCustomStateProperties</a></td><td>Properties that are added to every <code>store.$state</code> by <code>pinia.use()</code>.</td></tr><tr><td><a href="./interfaces/PiniaPlugin.html">PiniaPlugin</a></td><td>Plugin to extend every store.</td></tr><tr><td><a href="./interfaces/PiniaPluginContext.html">PiniaPluginContext</a></td><td>Context argument passed to Pinia plugins.</td></tr><tr><td><a href="./interfaces/SetupStoreDefinition.html">SetupStoreDefinition</a></td><td>Return type of <code>defineStore()</code> with a setup function. - <code>Id</code> is a string literal of the store&#39;s name - <code>SS</code> is the return type of the setup function</td></tr><tr><td><a href="./interfaces/StoreDefinition.html">StoreDefinition</a></td><td>Return type of <code>defineStore()</code>. Function that allows instantiating a store.</td></tr><tr><td><a href="./interfaces/StoreProperties.html">StoreProperties</a></td><td>Properties of a store.</td></tr><tr><td><a href="./interfaces/SubscriptionCallbackMutationDirect.html">SubscriptionCallbackMutationDirect</a></td><td>Context passed to a subscription callback when directly mutating the state of a store with <code>store.someState = newValue</code> or <code>store.$state.someState = newValue</code>.</td></tr><tr><td><a href="./interfaces/SubscriptionCallbackMutationPatchFunction.html">SubscriptionCallbackMutationPatchFunction</a></td><td>Context passed to a subscription callback when <code>store.$patch()</code> is called with a function.</td></tr><tr><td><a href="./interfaces/SubscriptionCallbackMutationPatchObject.html">SubscriptionCallbackMutationPatchObject</a></td><td>Context passed to a subscription callback when <code>store.$patch()</code> is called with an object.</td></tr></tbody></table><h2 id="Type-Aliases" tabindex="-1">Type Aliases <a class="header-anchor" href="#Type-Aliases" aria-label="Permalink to &quot;Type Aliases&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Type alias</th><th>Description</th></tr></thead><tbody><tr><td><a href="./type-aliases/ActionsTree.html">_ActionsTree</a></td><td>Type of an object of Actions. For internal usage only. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/DeepPartial.html">_DeepPartial</a></td><td>Recursive <code>Partial&lt;T&gt;</code>. Used by <a href="./type-aliases/Store.html">[&#39;$patch&#39;]</a>.</td></tr><tr><td><a href="./type-aliases/ExtractActionsFromSetupStore.html">_ExtractActionsFromSetupStore</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/ExtractActionsFromSetupStore_Keys.html">_ExtractActionsFromSetupStore_Keys</a></td><td>Type that enables refactoring through IDE. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/ExtractGettersFromSetupStore.html">_ExtractGettersFromSetupStore</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/ExtractGettersFromSetupStore_Keys.html">_ExtractGettersFromSetupStore_Keys</a></td><td>Type that enables refactoring through IDE. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/ExtractStateFromSetupStore.html">_ExtractStateFromSetupStore</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/ExtractStateFromSetupStore_Keys.html">_ExtractStateFromSetupStore_Keys</a></td><td>Type that enables refactoring through IDE. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/GettersTree.html">_GettersTree</a></td><td>Type of an object of Getters that infers the argument. For internal usage only. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/MapActionsObjectReturn.html">_MapActionsObjectReturn</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/MapActionsReturn.html">_MapActionsReturn</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/MapStateObjectReturn.html">_MapStateObjectReturn</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/MapStateReturn.html">_MapStateReturn</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/MapWritableStateObjectReturn.html">_MapWritableStateObjectReturn</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/MapWritableStateReturn.html">_MapWritableStateReturn</a></td><td>For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/Method.html">_Method</a></td><td>Generic type for a function that can infer arguments and return type</td></tr><tr><td><a href="./type-aliases/Spread.html">_Spread</a></td><td>For internal use <strong>only</strong>.</td></tr><tr><td><a href="./type-aliases/StoreObject.html">_StoreObject</a></td><td>For internal use <strong>only</strong>.</td></tr><tr><td><a href="./type-aliases/StoreWithActions.html">_StoreWithActions</a></td><td>Store augmented for actions. For internal usage only. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/StoreWithGetters.html">_StoreWithGetters</a></td><td>Store augmented with getters. For internal usage only. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/UnwrapAll.html">_UnwrapAll</a></td><td>Type that enables refactoring through IDE. For internal use <strong>only</strong></td></tr><tr><td><a href="./type-aliases/StateTree.html">StateTree</a></td><td>Generic state of a Store</td></tr><tr><td><a href="./type-aliases/Store.html">Store</a></td><td>Store type to build a store.</td></tr><tr><td><a href="./type-aliases/StoreActions.html">StoreActions</a></td><td>Extract the actions of a store type. Works with both a Setup Store or an Options Store.</td></tr><tr><td><a href="./type-aliases/StoreGeneric.html">StoreGeneric</a></td><td>Generic and type-unsafe version of Store. Doesn&#39;t fail on access with strings, making it much easier to write generic functions that do not care about the kind of store that is passed.</td></tr><tr><td><a href="./type-aliases/StoreGetters.html">StoreGetters</a></td><td>Extract the getters of a store type. Works with both a Setup Store or an Options Store.</td></tr><tr><td><a href="./type-aliases/StoreOnActionListener.html">StoreOnActionListener</a></td><td>Argument of <code>store.$onAction()</code></td></tr><tr><td><a href="./type-aliases/StoreOnActionListenerContext.html">StoreOnActionListenerContext</a></td><td>Context object passed to callbacks of <code>store.$onAction(context =&gt; {})</code> TODO: should have only the Id, the Store and Actions to generate the proper object</td></tr><tr><td><a href="./type-aliases/StoreState.html">StoreState</a></td><td>Extract the state of a store type. Works with both a Setup Store or an Options Store. Note this unwraps refs.</td></tr><tr><td><a href="./type-aliases/SubscriptionCallback.html">SubscriptionCallback</a></td><td>Callback of a subscription</td></tr><tr><td><a href="./type-aliases/SubscriptionCallbackMutation.html">SubscriptionCallbackMutation</a></td><td>Context object passed to a subscription callback.</td></tr></tbody></table><h2 id="Functions" tabindex="-1">Functions <a class="header-anchor" href="#Functions" aria-label="Permalink to &quot;Functions&quot;">​</a></h2><table tabindex="0"><thead><tr><th>Function</th><th>Description</th></tr></thead><tbody><tr><td><a href="./functions/acceptHMRUpdate.html">acceptHMRUpdate</a></td><td>Creates an <em>accept</em> function to pass to <code>import.meta.hot</code> in Vite applications.</td></tr><tr><td><a href="./functions/createPinia.html">createPinia</a></td><td>Creates a Pinia instance to be used by the application</td></tr><tr><td><a href="./functions/defineStore.html">defineStore</a></td><td>Creates a <code>useStore</code> function that retrieves the store instance</td></tr><tr><td><a href="./functions/disposePinia.html">disposePinia</a></td><td>Dispose a Pinia instance by stopping its effectScope and removing the state, plugins and stores. This is mostly useful in tests, with both a testing pinia or a regular pinia and in applications that use multiple pinia instances. Once disposed, the pinia instance cannot be used anymore.</td></tr><tr><td><a href="./functions/getActivePinia.html">getActivePinia</a></td><td>Get the currently active pinia if there is any.</td></tr><tr><td><a href="./functions/mapActions.html">mapActions</a></td><td>Allows directly using actions from your store without using the composition API (<code>setup()</code>) by generating an object to be spread in the <code>methods</code> field of a component.</td></tr><tr><td><a href="./functions/mapGetters.html"><s>mapGetters</s></a></td><td>Alias for <code>mapState()</code>. You should use <code>mapState()</code> instead.</td></tr><tr><td><a href="./functions/mapState.html">mapState</a></td><td>Allows using state and getters from one store without using the composition API (<code>setup()</code>) by generating an object to be spread in the <code>computed</code> field of a component.</td></tr><tr><td><a href="./functions/mapStores.html">mapStores</a></td><td>Allows using stores without the composition API (<code>setup()</code>) by generating an object to be spread in the <code>computed</code> field of a component. It accepts a list of store definitions.</td></tr><tr><td><a href="./functions/mapWritableState.html">mapWritableState</a></td><td>Allows using state and getters from one store without using the composition API (<code>setup()</code>) by generating an object to be spread in the <code>computed</code> field of a component.</td></tr><tr><td><a href="./functions/setActivePinia.html">setActivePinia</a></td><td>Sets or unsets the active pinia. Used in SSR and internally when calling actions and getters</td></tr><tr><td><a href="./functions/setMapStoreSuffix.html">setMapStoreSuffix</a></td><td>Changes the suffix added by <code>mapStores()</code>. Can be set to an empty string. Defaults to <code>&quot;Store&quot;</code>. Make sure to extend the MapStoresCustomization interface if you are using TypeScript.</td></tr><tr><td><a href="./functions/shouldHydrate.html">shouldHydrate</a></td><td>Returns whether a value should be hydrated</td></tr><tr><td><a href="./functions/skipHydrate.html">skipHydrate</a></td><td>Tells Pinia to skip the hydration process of a given object. This is useful in setup stores (only) when you return a stateful object in the store but it isn&#39;t really state. e.g. returning a router instance in a setup store.</td></tr><tr><td><a href="./functions/storeToRefs.html">storeToRefs</a></td><td>Creates an object of references with all the state, getters, and plugin-added state properties of the store. Similar to <code>toRefs()</code> but specifically designed for Pinia stores so methods and non reactive properties are completely ignored.</td></tr></tbody></table>',10)]))}const f=e(n,[["render",i]]);export{u as __pageData,f as default};
